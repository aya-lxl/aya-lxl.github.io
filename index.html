<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aya-lxl.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="直到海角天涯">
<meta property="og:url" content="https://aya-lxl.github.io/index.html">
<meta property="og:site_name" content="直到海角天涯">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="aya_lxl@163.com">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aya-lxl.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>直到海角天涯</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">直到海角天涯</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aya-lxl.github.io/2021/03/05/%E5%87%A0%E4%B8%AAlinux%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aya_lxl@163.com">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="直到海角天涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/05/%E5%87%A0%E4%B8%AAlinux%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">几个linux测试题目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-05 19:23:20" itemprop="dateCreated datePublished" datetime="2021-03-05T19:23:20+08:00">2021-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-06 09:02:52" itemprop="dateModified" datetime="2021-03-06T09:02:52+08:00">2021-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>晚上闲来无事，发现了一个linux运维测试，马上登陆，来了一场毫无准备的考试。虽然初中高三级测试通过，但是发现自己好多曾经学过的东西忘记了，也发现了一些有意思的题目，还有一些不知道的，特此记录。有些答案可能有问题，欢迎批评指正(<a href="mailto:&#97;&#121;&#97;&#95;&#x6c;&#x78;&#108;&#64;&#x31;&#54;&#x33;&#x2e;&#99;&#111;&#109;">&#97;&#121;&#97;&#95;&#x6c;&#x78;&#108;&#64;&#x31;&#54;&#x33;&#x2e;&#99;&#111;&#109;</a>)。</p>
<p>地址<a target="_blank" rel="noopener" href="https://developer.aliyun.com/exam?spm=5176.8902351.1364563.42.7ef3728eJ4r4rO">https://developer.aliyun.com/exam?spm=5176.8902351.1364563.42.7ef3728eJ4r4rO</a></p>
<h5 id="一、初级测试"><a href="#一、初级测试" class="headerlink" title="一、初级测试"></a>一、初级测试</h5><ol>
<li><p><strong>多用于同类局域网间的互联设备为</strong>（<code>B</code>）<br>A. 网关<br>B. 网桥<br>C. 中继器<br>D. 路由器</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.3rxing.org/question/ec16980c4c446762266.html">https://www.3rxing.org/question/ec16980c4c446762266.html</a></p>
<p>1）集线器、中继器。用于同一网段上不同计算机之间的连接。工作在物理层。<br>功能：将经过一定距离传输后衰减和失真的电信号放大整形后再发送到网段上去，以实现更  长距离的传输。只能连接同一类型的局域网。<br>集线器工作在局域网环境，属于物理层的互联设备.</p>
<p>2）网桥、第二层交换机。用于不同网段上计算机之间的连接。工作在数据链路层。<br>功能：在单个网路中进行存储转发。可连接不同类型的局域网。</p>
<p>3）路由器、第三层交换机。用于各网络上计算机之间的连接。工作在网络层。<br>功能：在多个网络中存储转发。路由选择。</p>
</blockquote>
</li>
<li><p>下列的哪一个不是linux常用的shell（<code>D</code>）<br>A. SH<br>B. Bash<br>C. Zsh<br>D. XSH</p>
</li>
<li><p>在linux中，想使用本地yum源，需要去哪个文件修改路径和参数？<code>C</code><br>A. CentOS-Base.repo           <code>是yum 网络源的配置文件</code><br>B. CentOS-Debuginfo.repo<br>C. CentOS-Media.repo      <code>是yum 本地源的配置文件</code><br>D. CentOS-Vault.repo</p>
</li>
<li><p>Internet中采用的交换技术是（<code>C</code>）<br>A. 电路交换<br>B. 报文交换<br>C. 分组交换<br>D. 信元交换</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/apolloren/p/13027368.html">https://www.cnblogs.com/apolloren/p/13027368.html</a></p>
</blockquote>
</li>
<li><p>以下关于yum命令的说法哪项是错误的？<code>A</code><br>A. yum不可以更改yum源<br>B. yum可以方便的实现软件包升级<br>C. yum也是通过RPM包安装软件<br>D. yum可以解决软件依赖关系</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LiuChunfu/p/8052890.html">https://www.cnblogs.com/LiuChunfu/p/8052890.html</a></p>
</blockquote>
</li>
<li><p>城域网英文缩写是（<code>D</code>）<br>A. LAN   <code>局域网（Local Area Network，缩写为 LAN）</code><br>B. WAN    <code>广域网 Wide Area Network，缩写为 WAN</code><br>C. MEN<br>D. MAN    <code>城域网（Metropolitan Area Network，缩写为 MAN）</code></p>
</li>
<li><p>OSI参考模型的（<code>C</code>）保证一个系统应用层发出的信息能被另一个系统的应用层读出。<br>A. 传输层<br>B. 会话层<br>C. 表示层<br>D. 应用层</p>
</li>
<li><p>路由器是用于联结逻辑上分开的（<code>C</code>）网络<br>A. 1个<br>B. 2个<br>C. 多个<br>D. 无数个</p>
</li>
<li><p>在局域网标准中共定义了四个层。<code>正确</code></p>
</li>
<li><p>应用网关是在应用层实现网络互连的设备。<code>正确</code></p>
</li>
<li><p>帧中继的设计主要是针对局域网到连为目标。<code>正确</code></p>
</li>
<li><p>ansible的Host-pattern支持正则表达式。<code>正确</code></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c82737b5485c">https://www.jianshu.com/p/c82737b5485c</a></p>
</blockquote>
</li>
<li><p>IP协议是（<code>A,D</code>）<br>A. 网际层协议<br>B. 和TCP协议一样，都是面向连接的协议<br>C. 传输层协议<br>D. 面向无连接的协议，可能会是数据丢失</p>
</li>
<li><p>哪个命令可以用于按页查看一个文件的内容 : <code>A,B</code><br>A. less<br>B. more<br>C. cat<br>D. sed</p>
</li>
<li><p>下面哪些命令可用于查看linux的负载：<code>A,B,C</code><br>A. top</p>
<blockquote>
<p>可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过top命令所提供的互动式界面，用热键可以管理。</p>
</blockquote>
<p>B. htop</p>
<blockquote>
<p>监控软件Htop，姑且称之为top的增强版，相比top其有着很多自身的优势。</p>
</blockquote>
<p>C. uptime</p>
<blockquote>
<p>能够打印系统总共运行了多长时间和系统的平均负载。uptime命令可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。</p>
</blockquote>
<p>D. free </p>
<blockquote>
<p>可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36357820/article/details/76606113">https://blog.csdn.net/qq_36357820/article/details/76606113</a></p>
</blockquote>
</li>
</ol>
<h5 id="二、中级测试"><a href="#二、中级测试" class="headerlink" title="二、中级测试"></a>二、中级测试</h5><ol>
<li><p>下列（）中使用多令牌：<code>C</code><br>A. 以太网<br>B.令牌环网<br>C. FDDI网<br>D. NOVELL网</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/penghuwan/p/7778234.html">https://www.cnblogs.com/penghuwan/p/7778234.html</a></p>
</blockquote>
</li>
<li><p>下面属于路由选择协议的是（<code>B</code>）<br>A. TCP/IP<br>B. RIP<br>C. IPX/SPX<br>D. AppleTalk</p>
</li>
<li><p>以下哪条命令无法查看当前登录用户root隶属于哪些组？<code>C</code><br>A. grep root /etc/gshadow<br>B. id<br>C. newgrp  <code>用于登入另一个群组</code><br>D. groups</p>
</li>
<li><p>下列交换方式中，实时性最好的是（<code>C</code>）<br>A. 报文分组交换<br>B. 报文交换<br>C. 电路交换<br>D. 各种方法都一样</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/205251011">https://zhuanlan.zhihu.com/p/205251011</a></p>
</blockquote>
</li>
<li><p>5类UTP双绞线规定的最高传输特性是（<code>C</code>）<br>A. 20Mbps<br>B. 20MHZ<br>C. 100Mbps<br>D. 100MHZ</p>
</li>
<li><p>数据解封装的过程是：<code>流-帧-包-段-数据</code><br>当数据在网络层时，称之为（<code>B</code>）<br>A. Segment<br>B. Packet<br>C. Bit<br>D. Frame</p>
<blockquote>
<p><img src="https://s3.ax1x.com/2021/03/05/6e5blt.png" alt="6e5blt.png"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/raykuan/p/6555479.html">https://www.cnblogs.com/raykuan/p/6555479.html</a>，<code>侵权删</code>。</p>
</blockquote>
</li>
<li><p>以下说法错误的是：<code>C</code><br>A. 默认创建的二进制文件不具有可自行权限<br>B. Vim的配置文件名为.vimrc<br>C. 一个i节点只能对应一个文件  <code>硬链接与软连接</code><br>D. linux中的设备是以文件的形式进行管理</p>
</li>
<li><p>在大多数linux发行版本中，图形界面的运行级别为：<code>D</code><br>A. 1<br>B. 2<br>C. 3  <code>命令行模式</code><br>D. 5 <code>图形界面</code></p>
<blockquote>
<p>0-关机（千万不要设为默认）<br>1-单用户模式<br>2-多用户模式，不带NFS（网络文件系统）<br>3-完整的多用户模式<br>4-保留的<br>5-X窗口，图形用户界面<br>6-重启（千万不要设为默认）<br><code>使用命令init命令更改运行级别</code><br>如：关机——init 0<br>​        重启——init 6</p>
</blockquote>
</li>
<li><p>ATM既可以用于广域网，又可以用于局域网，这是因为它的工作原理与Ethernet基本上是相同的。<code>错误</code></p>
</li>
<li><p>对等网络结构中连接网络节点的地位平等，安装在网络节点上的局域网操作系统具有基本相同的结构。<code>之前</code></p>
</li>
<li><p>连接多LAN的交换多兆位数据服务（SDMS）是一种高速无连接的交换式数字通信网，而帧中继是一种面向连接的数值通信网。<code>正确</code></p>
</li>
<li><p>ISO划分网络层次的基本原则是：不同节点具有相同的层次，不同节点的相同层次具有相同的功能。<code>正确</code></p>
</li>
<li><p>linux系统中，yum源配置文件中，以下哪些是配置文件中的参数项？<code>A,C,D</code><br>A. Name=<br>B. enable=  <code>应该是：enabled</code><br>C. baseurl=<br>D. gpgcheck=</p>
</li>
<li><p>在shell的双引号中，所有的字符都能解释成字符本身，拥有“调用变量的值”，“引用命令”和“转义符”的特殊含义，但以下哪些除外？<code>A,B,D</code><br>A. “$”<br>B. “`”<br>C. “&quot;<br>D. “‘“</p>
<blockquote>
<p><strong>shell 中单引号和双引号区别</strong><br>‘’ 在单引号中所有的字符包括特殊字符（$,’’,<code>和\）都将解释成字符本身而成为普通字符。 “” 在双引号中，除了$, &#39;&#39;, </code>和\以外所有的字符都解释成字符本身，拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义。<br>注：\转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。如$将输出“$”符号，而不当做是变量引用。</p>
</blockquote>
</li>
<li><p>以下说法错误的是：<code>B,D</code><br>A. 中继器是工作在物理层的设备<br>B. 集线器和以太网交换机工作在数据链路层 <code>集线器工作在物理层</code></p>
<blockquote>
<ul>
<li>工作在物理层，对收到的信号进行放大，以扩大网络的传输距离。</li>
<li>集线器发送数据没有针对性，而是采用广播的形式发送，也就是说当它要向某个节点发送数据时，不是直接把数据发送到目的端口，而是把<strong>数据包</strong>发送到会集线器相连的所有节点</li>
<li>当以 HUB 为中心设备时，网络中某条线路发生了故障并不影响其他的端口工作</li>
</ul>
</blockquote>
<p>C. 路由器是工作在网络层的设备</p>
<p>D. 桥能隔离网络层广播 <code>网桥只能隔离冲突域，路由器能隔离广播域</code></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ether_lai/article/details/19006623">https://blog.csdn.net/ether_lai/article/details/19006623</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74366236">https://zhuanlan.zhihu.com/p/74366236</a>​    </p>
</blockquote>
</li>
<li><p>使用什么方法可以查看linux启动信息？<code>B,D</code><br>A. mesg -d<br>B. dmesg<br>C. cat /etc/mesg<br>D. cat /var/log/dmesg</p>
</li>
</ol>
<h5 id="三、高级测试"><a href="#三、高级测试" class="headerlink" title="三、高级测试"></a>三、高级测试</h5><ol>
<li><p>能从数据信号波形中提取同步信号的典型编码是（<code>D</code>）<br>A. 归零码<br>B. 不归零码<br>C. 定比码<br>D. 曼彻斯特编码</p>
<blockquote>
<p><strong>曼彻斯特编码</strong>（<strong>Manchester coding</strong>），又称<strong>自同步码</strong>、<strong>相位编码</strong>（<strong>phase encoding</strong>，<strong>PE</strong>），能够用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7">信号</a>的变化来保持发送设备和接收设备之间的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5">同步</a>。它用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%A3%93">电压</a>的变化来分辨0和1，从高电平到低电平的跳变代表1，而从低电平到高电平的跳变代表0(as per G.E.Tomas编码方式)。从高电平到低电平的跳变代表0，而从低电平到高电平的跳变代表1(as per IEEE 802.3编码方式)，下方有所展示。[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81#cite_note-:0-1">1]</a> 信号的保持不会超过一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9">比特位</a>的时间间隔。即使是0或1的序列，信号也将在每个时间间隔的中间发生跳变。这种跳变将允许接收设备的时钟与发送设备的时钟保持一致。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81">https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81</a></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6eb1oT"><img src="https://s3.ax1x.com/2021/03/05/6eb1oT.png" alt="6eb1oT.png"></a></p>
</blockquote>
</li>
<li><p>在<strong>Ansible-console</strong>中设置并发数要用到的参数是？：<code>D</code><br>A. concurrence<br>B. parallel<br>C. threading<br>D. fork  // <code>forks n</code></p>
</li>
<li><p><em>默认</em> <em>Linux</em> <em>系统中</em> <em>ls || echo “123” &amp;&amp; pwd</em> *这条命令，输出的结果为：<code>C</code><br>A. 显示当前目录下的内容<br>B. 屏幕打印显示 123<br>C. 显示当前目录下的内容以及当前目录的绝对位置<br>D. 屏幕打印显示 123 以及当前目录的绝对位置</p>
<blockquote>
<p>在 Linux下，不管你是启动一个桌面程序也好，还是在控制台下运行命令，所有的程序在结束时，都会返回一个数字值，这个值叫做返回值，或者称为错误号(Error Number)。<br>在控制台下，有一个特殊的环境变量 **$?**，保存着前一个程序的返回值。只要返回值是 0，就代表程序执行成功了；如果 $? 变量的值不是 0 的话，就表示上一个命令在执行的过程中出错了。</p>
</blockquote>
<blockquote>
<p>以下来自鸟哥私房菜<a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0320bash.php">http://cn.linux.vbird.org/linux_basic/0320bash.php</a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6ebrFO"><img src="https://s3.ax1x.com/2021/03/05/6ebrFO.gif" alt="6ebrFO.gif"></a></p>
<p>上面这张图显示的两股数据中，上方的线段为不存在 /tmp/abc 时所进行的命令行为，下方的线段则是存在 /tmp/abc 所在的命令行为。如上所述，下方线段由于存在 /tmp/abc 所以导致 $?=0 ，让中间的 mkdir 就不运行了！ 并将 $?=0 继续往后传给后续的 touch 去利用啦！瞭乎？在任何时刻你都可以拿上面这张图作为示意！</p>
</blockquote>
<blockquote>
<p>由于命令是一个接着一个去运行的，因此，如果真要使用判断， 那么这个 &amp;&amp; 与 || 的顺序就不能搞错。一般来说，假设判断式有三个，也就是：</p>
<p>command1 &amp;&amp; command2 || command3<br>而且顺序通常不会变，因为一般来说， command2 与 command3 会放置肯定可以运行成功的命令。<br>上面命令执行后结果如下：<img src="https://s3.ax1x.com/2021/03/05/6e5zkQ.png" alt="6e5zkQ.png"></p>
</blockquote>
</li>
<li><p><em>下面哪个命令用来显示系统中各个分区</em> <em>inode</em> <em>的使用情况？</em><code>A</code><br>A. df -i<br>B. df -h<br>C. free -b <br>D. du -a -c</p>
</li>
<li><p>采用专用线路通信时，可以省去的通信阶段是：<code>A</code><br>A. 建立通信线路<br>B. 建立数据传输链路<br>C. 传送通信控制信号和数据<br>D. 双方确认通信结束</p>
</li>
<li><p>命令 free -h 执行结果如下：<br>[root@localhost sh]# free -h<br>total used free shared buffers cached<br>Mem: 988M 531M 457M 316K 102M 281M<br>-/+ buffers/cache: 146M 842M<br>Swap: 511M 0B 511M</p>
<p>执行命令 y=$(free -h | grep Mem | awk ‘{print $4}’ | cut -d M -f 1) | [ $y -ge 500 ] &amp;&amp; echo yes || echo no<br>结果为：<code>D</code>  457与500比较<br>A. 457<br>B. 500<br>C. yes<br>D. no</p>
</li>
<li><p><strong>在使用了shadow口令的Linux系统中，/etc/passwd和 /etc/shadow两个文件的权限正确的是</strong>：<strong>C</strong><br>A. -rw-r—– ， -r——–<br>B. -rw-r–r– ， -r–r–r–<br>C. -rw-r–r– ， ———-<br>D. -rw-r–rw- ， -r—–r–</p>
</li>
<li><p>如果服务器的CPU逻辑核心数量是4，然后用ansible_processor_vcpus*10来指定httpd的监听端口，那成功执行后，服务器httpd的监听端口一般会是？<br><code>D，ansible_processor_vcpus显示CPU个数</code></p>
<p>A. 400<br>B. 200<br>C. 20<br>D. 40</p>
</li>
<li><p><em>playbook是由一个或多个“play”组成的列表</em></p>
</li>
<li><p>通过引入CRC校验以及确认和重传机制，使得网络可实现可靠的数据传输。<code>错误</code></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aya-lxl.github.io/2021/02/28/%E7%BB%84%E5%90%88%E5%8A%9F%E8%83%BD%E6%9C%BA%E5%99%A8%E8%BD%AF%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aya_lxl@163.com">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="直到海角天涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%BB%84%E5%90%88%E5%8A%9F%E8%83%BD%E6%9C%BA%E5%99%A8%E8%BD%AF%E4%BB%B6/" class="post-title-link" itemprop="url">组合功能机器软件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-28 16:57:51" itemprop="dateCreated datePublished" datetime="2021-02-28T16:57:51+08:00">2021-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-01 11:21:23" itemprop="dateModified" datetime="2021-03-01T11:21:23+08:00">2021-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%95%E7%89%87%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">单片机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0、简述"><a href="#0、简述" class="headerlink" title="0、简述"></a>0、简述</h4><p>单片机使用LPC1115，采用ucos-ii。</p>
<p>程序主要包括：1个主任务、3个功能任务，1个串口发送任务，1个状态指示灯任务，1个蜂鸣器任务。</p>
<p>功能任务就是实现机器主要功能的任务，与机器的应用场合有很大的关系，所以在此不做过分详细的说明。每个功能可以实现开启、暂停、结束等命令，实现方式在下面说明。</p>
<p>其它几个任务是辅助性的任务，为了更好地服务于机器功能的实现。</p>
<h4 id="1、主任务"><a href="#1、主任务" class="headerlink" title="1、主任务"></a>1、主任务</h4><p>解析上位机的命令，并向任务发送命令。</p>
<p>主任务结构伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="title">queue_func_insert</span><span class="params">(struct andrdata* andr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(andr-&gt;cmd)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> FUNCTION_CMD_PUMP:</span><br><span class="line">    &#123;</span><br><span class="line">        OSQPost(q_pump, (<span class="keyword">void</span>*)(andr_pump_buf + pump_write));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="title">func_insert</span><span class="params">(struct andrdata* andr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue_func_insert(andr) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> CMD_ERROR;</span><br><span class="line"></span><br><span class="line">    mbox_msg = OSMboxPend(from_task, OS_TICKS_PER_SEC / <span class="number">50</span>, &amp;err);</span><br><span class="line">    code = *mbox_msg;</span><br><span class="line">    <span class="comment">//根据返回结果处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_main_func</span><span class="params">(<span class="keyword">void</span>* pvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(andr_recv_queue.is_empty())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            andr = andr_queue_get(&amp;andr_recv_queue);</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            code = func_insert(andr);</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主任务处理流程：</p>
<p>①解析上位机命令</p>
<p>②判断分析，如果合适，将命令发送至任务，等待任务应答。</p>
<p>这样处理意在将各功能任务与上位机命令分离，各部分相互独立，减弱耦合。</p>
<p>③主任务根据任务的应答进行后续处理。</p>
<h4 id="2、功能任务"><a href="#2、功能任务" class="headerlink" title="2、功能任务"></a>2、功能任务</h4><p>功能任务用来实现各个具体的功能，虽然因任务的不同而有所变化，但处理流程基本一致。代码框架如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数用来在功能运行过程中，接收上位机的一些命令，</span></span><br><span class="line"><span class="comment">诸如暂停、恢复、停止等，并且在暂停过程中还有超时处理。</span></span><br><span class="line"><span class="comment">若有其它控制需求，还可以比较方便地增加。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">wait_mbox2task</span><span class="params">(<span class="keyword">uint8_t</span> index, <span class="keyword">uint16_t</span> timeout, <span class="keyword">uint8_t</span>* state, fun_call func, <span class="keyword">uint8_t</span> para)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mbox_m = OSMboxPend(mbox, timeout, &amp;err);</span><br><span class="line">    <span class="keyword">if</span>(err != OS_NO_ERR)</span><br><span class="line">        <span class="keyword">return</span> FUNC_NONE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span>(*mbox_m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> FUNCTION_SUSPEND:</span><br><span class="line">        &#123;</span><br><span class="line">            OSMboxPost(md-&gt;mbox, &amp;md-&gt;msg);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mbox_m = OSMboxPend(mbox, OS_TICKS_PER_SEC, &amp;err);</span><br><span class="line">                <span class="keyword">if</span>(err == OS_NO_ERR)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">switch</span>(*mbox_m)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">case</span> FUNCTION_RESUME:</span><br><span class="line">                            md-&gt;msg = ALARM_CMD_OK;</span><br><span class="line">                            OSMboxPost(md-&gt;mbox, &amp;md-&gt;msg);</span><br><span class="line">                            <span class="keyword">return</span> FUNC_NONE;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> FUNC_STOP:</span><br><span class="line">                            <span class="comment">//...</span></span><br><span class="line">                            <span class="keyword">return</span> FUNC_STOP;</span><br><span class="line">                           </span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            md-&gt;msg = ALARM_CMD_ERROR;</span><br><span class="line">                            OSMboxPost(md-&gt;mbox, &amp;md-&gt;msg);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(++suspend_time &gt;= SUSPEND_TIMEOUT)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> FUNC_TIMEOUT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> FUNC_STOP:</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">return</span> FUNC_STOP;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FUNC_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_pump</span><span class="params">(<span class="keyword">void</span>* pvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        andr = OSQPend(q_pump, OS_TICKS_PER_SEC, &amp;err);</span><br><span class="line">        <span class="keyword">if</span>(err != OS_NO_ERR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//andr参数检查</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//事件更新与处理</span></span><br><span class="line">            </span><br><span class="line">            ret = wait_mbox2task();</span><br><span class="line">            <span class="keyword">switch</span>(ret)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> FUNC_STOP:</span><br><span class="line">                <span class="comment">//..</span></span><br><span class="line">                <span class="keyword">goto</span> TASK_STOP;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> FUNC_TIMEOUT:</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">goto</span> TASK_STOP;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    TASK_STOP:</span><br><span class="line">        stop_task(flag_stop, flag_deal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在任务执行过程中，检查邮箱是否有数据到来：如果有，则分析具体动作，并执行之；否则就继续运行。命令包括几个方面：暂停（需要处理超时，不能长时间暂停）、恢复、停止（结束任务）等。</p>
<p>因不同任务有不同的特点，所以各个任务会有各自的处理细节。比如某个任务工作时，仅仅需要计时即可，当达到定时要求后结束执行即可。而另一个任务功能则需要计量液体体积，同时检测水桶的水位，如果水位低于警报值，那么需要提醒用户或者报警；另一方面，向水桶中注水时则需要关注高水位警报。</p>
<h4 id="3、辅助任务"><a href="#3、辅助任务" class="headerlink" title="3、辅助任务"></a>3、辅助任务</h4><h5 id="（1）串口发送任务"><a href="#（1）串口发送任务" class="headerlink" title="（1）串口发送任务"></a>（1）串口发送任务</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_uart_send</span><span class="params">(<span class="keyword">void</span>* pvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        us = OSQPend(q_uart_send, <span class="number">0</span>, &amp;err);</span><br><span class="line">        <span class="keyword">if</span>(err != OS_NO_ERR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(us-&gt;com)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> UART_TO_RS232:</span><br><span class="line">            cmd_resp(us-&gt;UART_TO_RS485andr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> UART_TO_RS485:</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; UART_SEND_COUNT; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                UARTSend(data, len);</span><br><span class="line">                OSSemPend(, , &amp;err);</span><br><span class="line">                <span class="keyword">if</span>(err != OS_NO_ERR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//do something else</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在其它位置调用下面的函数用以发送数据。</span></span><br><span class="line"><span class="comment">在本项目的实际应用中，不会有问题，但是这里仍不完善，有待改进。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">mb_send_data</span><span class="params">(struct uart_send* us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    send_buf[send_write] = *us;</span><br><span class="line">    OSQPost(q_uart_send, (<span class="keyword">void</span>*)(send_buf + send_write));</span><br><span class="line">    send_write = (send_write + <span class="number">1</span>) % Q_SIZE_SEND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序的不同位置会向串口发送数据，其实只是发送到队列，在这个任务中处理这些待发送的数据。结合实际的应用需求，单片机UART0通过扩展芯片外接有两个设备：上位机、Modbus设备。上位机是rs232接口，Modbus设备是rs485接口，并且Modbus设备是从设备，所以在处理Modbus设备时需要处理数据应答与重发问题。</p>
<p>可以这样简单理解。数据有多个源头，但是均需要从同一个串口发送，那么将他们放在一个队列中，在一个任务中将数据一个一个地取出并发送。在发送任务中，根据数据的不同目的设备，通过RS232或者RS485发送输出。</p>
<p><img src="https://s3.ax1x.com/2021/02/28/691xg0.png" alt="691xg0.png"></p>
<p>因为数据的接收也是从同一个uart进入，所以有可能丢失数据。比如在处理rs485设备时，rs232接口有数据过来，或者相反的情形。但是这种情况比较少，有几个原因：①上位机数据发送有比较大的时间间隔；②从rs485发送数据时是报警、开启停止任务的时候。<code>但仍然存在数据丢失的可能性</code>,所以才会有数据重发机制。</p>
<h5 id="（2）状态指示与蜂鸣器"><a href="#（2）状态指示与蜂鸣器" class="headerlink" title="（2）状态指示与蜂鸣器"></a>（2）状态指示与蜂鸣器</h5><p>这里的处理与数据发送任务比较类似，数据来源于多个位置，但是均需要从同一个UART输出，所以使用队列的处理方式，在任务中从队列中取数据处理。</p>
<p>状态指示灯需要实现不同的效果，比如闪烁间隔、周期、次数等，各功能任务的状态显示均需通过状态指示任务处理，最后再通过串口发送任务发送数据。</p>
<p>还有一个报警功能。所谓的报警，就是通过状态指示灯与蜂鸣器来提醒用户，并且上位机在查询状态时，也会检查到报警状态并提示。</p>
<h5 id="（3）空闲任务"><a href="#（3）空闲任务" class="headerlink" title="（3）空闲任务"></a>（3）空闲任务</h5><p>电路板上有一个状态灯，将其放在空闲任务中，根据任务的不同状态，显示不同的状态。比如在空闲时为呼吸灯效果；有任务工作时，会是闪烁的状态；如果有报警，则以比较快的速度闪烁。</p>
<p>其实在各功能运行时，大部分时间都是阻塞的状态，所以空闲任务会运行大部分时间，将状态灯放在这里进一步减轻了主要任务的处理压力。</p>
<h5 id="（4）其它细节"><a href="#（4）其它细节" class="headerlink" title="（4）其它细节"></a>（4）其它细节</h5><ul>
<li><p>任务优先级</p>
<p>因为涉及到主任务与功能任务之间的通信以及串口数据发送问题，所以需要注意各个优先级的设置。在本项目中，功能任务优先级最高，主任务优先级次之，接着是串口发送任务，最后是蜂鸣器与状态指示任务。</p>
</li>
<li><p>同时工作的任务数量限制</p>
<p>这主要是实际应用的需求才这样设计，在上述代码中未体现。</p>
<p>一个问题是如何记录正在工作的任务及其数量？这里使用一个字节位的方式来处理。如果某个功能正在运行，那么将相应的位置1，完成后清0，统计1的数量就可以得到正在工作的任务的数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="title">get_bits_count</span><span class="params">(<span class="keyword">uint8_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; data; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data &amp;= (data - <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，单片机RAM有限，不可能同时运行太多的任务。</p>
</li>
<li><p>命令处理</p>
<p>指通信协议方面，需要做一些处理，包括命令的解析与数据打包，命令的应答等。同时，也要注意不同设备状态下命令的处理，比如：任务已经打开，不允许再次打开操作，否则返回错误命令等。</p>
</li>
<li><p>看门狗</p>
<p>采用外部看门狗芯片，放在主任务中处理，当然也还有其它处理方式，但是我理解不应该放在定时器中，因为有可能程序已经死机，但是定时器仍在运行，起不到应有的作用。</p>
</li>
<li><p>其它</p>
<p>报警的标记与清除、交易记录、参数设置、数据保存与读取（互斥量保护）等方面的内容。</p>
</li>
</ul>
<h4 id="4、问题"><a href="#4、问题" class="headerlink" title="4、问题"></a>4、问题</h4><p>（1）RS485接口速度</p>
<p>板子的rs232与rs485从同一个uart引出，但是对于rs485接口，当波特率超过9600，数据收发就会出现错误，但是RS232即使波特率到了115200也是没有问题的。</p>
<p>板子与485设备均在机器内部，长度可能也就几十公分，在开发、测试时长度更短，并且总线上只有这一个485设备。</p>
<p>一个原因是板子的设计问题，另一个是接地问题，还可能是软件处理收发方向的问题。这个需要后续进一步地验证。</p>
<p>（2）液体计量精度</p>
<p>在管路上有一个编码器，通过统计编码器脉冲数可以计算得到流过的液体体积。当然精度不是很高，一是没有高精度的流量计，二是安装方式也会有很大的影响。因为并没有拿到一个产品的精确参数，只能通过多次测试来得到比较精确地参数。</p>
<p>当然，本产品也不需要很高的精度，否则就需要更高精度的物理实现了。</p>
<h4 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h4><p>本文从应用的角度总结了项目的软件结构，整个软件还包括上位机通信协议设计，这是很重要的一部分。其实这里的上位机就是一个运行Android系统的屏，安装在机器上作为用户操作的界面，与它的通信通过RS232进行，Android屏作为通信的发起者，这里的单片机程序接收数据并应答。</p>
<p>整个项目从软件的设计、开发调试，到最后的测试，这个过程中遇到了一些问题，还有一些很低级的错误。但是因为涉及到多个部门，所以需要耐心沟通，慢慢调试，找出问题并解决之。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aya-lxl.github.io/2021/02/28/%E8%87%AA%E5%8A%A8%E5%BC%80%E5%85%B3%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aya_lxl@163.com">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="直到海角天涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E8%87%AA%E5%8A%A8%E5%BC%80%E5%85%B3%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">自动开关测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 10:52:25 / 修改时间：11:12:27" itemprop="dateCreated datePublished" datetime="2021-02-28T10:52:25+08:00">2021-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="自动开关测试"><a href="#自动开关测试" class="headerlink" title="自动开关测试"></a>自动开关测试</h4><p>软件写差不多了，就需要机器上完整地运行、测试，检查其中可能存在的错误，长时间运行的可靠性等。本篇的主题是自动开关测试，通过模拟开关变化，使机器反复地运行、停止。</p>
<p>项目中机器的启动与停止有多种方式，但无论如何均需要打开、关闭动作，这里的测试就是针对开关的模拟而设计的。</p>
<p>其中一种机器的开关方式：打开开关，等待一段时间，关闭，等待一段时间，再打开，如此循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> randseed;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">curl_rand</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 返回一个无符号32位整型的伪随机数. */</span></span><br><span class="line">    r = randseed = randseed * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (r &lt;&lt; <span class="number">16</span>) | ((r &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint16_t</span> <span class="title">random</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> curl_rand()%<span class="number">2000</span> + <span class="number">30</span>; <span class="comment">//避免数据太小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_on_off</span><span class="params">(<span class="keyword">void</span>* pvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> sec;</span><br><span class="line">	</span><br><span class="line">    pvData = pvData;</span><br><span class="line">    randseed =seconds_cal();<span class="comment">//用时间产生一个初始值</span></span><br><span class="line">    </span><br><span class="line">    OSTimeDlyHMSM(<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sec=random()%<span class="number">120</span>+<span class="number">10</span>;</span><br><span class="line">        OSTimeDlyHMSM(<span class="number">0</span>,sec/<span class="number">60</span>,sec%<span class="number">60</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        SWITCH_OPEN(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        sec=random()%(<span class="number">4</span>*<span class="number">60</span>)+<span class="number">10</span>;</span><br><span class="line">        OSTimeDlyHMSM(<span class="number">0</span>,sec/<span class="number">60</span>,sec%<span class="number">60</span>,<span class="number">0</span>);</span><br><span class="line">	 </span><br><span class="line">        SWITCH_CLOSE(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开或者关闭的时间是一个伪随机数，并且对随机数的大小进行了限制，避免过长或过短时间的开或者关。</p>
<p>还有一种机器，是通过自复位按钮来确定开关状态的，此时就是通过脉冲实现的。模拟代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_lpg_button</span><span class="params">(<span class="keyword">void</span>* pvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> sec;</span><br><span class="line">	</span><br><span class="line">    pvData = pvData;</span><br><span class="line">    randseed =seconds_cal();</span><br><span class="line">    </span><br><span class="line">    OSTimeDlyHMSM(<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sec=random()%<span class="number">120</span>+<span class="number">10</span>;</span><br><span class="line">        OSTimeDlyHMSM(<span class="number">0</span>,sec/<span class="number">60</span>,sec%<span class="number">60</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        SWITCH_OPEN(<span class="number">0</span>);</span><br><span class="line">        OSTimeDlyHMSM(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">300</span>);</span><br><span class="line">        SWITCH_CLOSE(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        sec=random()%(<span class="number">4</span>*<span class="number">60</span>)+<span class="number">10</span>;</span><br><span class="line">        OSTimeDlyHMSM(<span class="number">0</span>,sec/<span class="number">60</span>,sec%<span class="number">60</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        SWITCH_OPEN(<span class="number">1</span>);</span><br><span class="line">        OSTimeDlyHMSM(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">300</span>);</span><br><span class="line">        SWITCH_CLOSE(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码模拟脉冲时延时是300ms，实际的按钮脉冲时间不会这么长，主要是因为模拟软件运行所使用的板子的问题。</p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>上述原理与实现都很简单，重点在于这样一种思想：工欲善其事，必先利其器。如果人去操作测试，效率不高，并且也很费时间，如果期间还在做其它事情，就会有忘记的可能，使用这些小工具就会避免这些问题。</p>
<p>但是另一方面，模拟测试也只会测试一方面的问题，如果想要全面的自动测试，还需要做大量的工作。</p>
<p>实际工作中随着项目的进行，还写了其它一些小工具，比如通信协议的校验值计算、数据转发与监控等等。这些工具的使用，对于发现问题、解决问题起到了很大的帮助。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aya-lxl.github.io/2021/02/24/%E5%8D%95%E7%89%87%E6%9C%BAPWM%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aya_lxl@163.com">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="直到海角天涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/%E5%8D%95%E7%89%87%E6%9C%BAPWM%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90/" class="post-title-link" itemprop="url">单片机PWM播放音乐</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-24 11:37:00 / 修改时间：11:37:53" itemprop="dateCreated datePublished" datetime="2021-02-24T11:37:00+08:00">2021-02-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%95%E7%89%87%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">单片机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用单片机PWM播放音乐"><a href="#使用单片机PWM播放音乐" class="headerlink" title="使用单片机PWM播放音乐"></a>使用单片机PWM播放音乐</h2><p>一个偶然的机会，看到一篇文章（即参考中的第一项），觉得挺有意思，想搞一下。而且最近一直在搞比例调节阀的事情，就是使用到了pwm。</p>
<h3 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h3><p><strong>（1）音调</strong></p>
<p>每一个音调都有一个固定的频率，比如下面这个图：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yokRSA"><img src="https://s3.ax1x.com/2021/02/21/yokRSA.jpg" alt="yokRSA.jpg"></a></p>
<p>只要使PWM的频率与相应的音调频率相同即可，当需要改变音调时，修改pwm周期即可。</p>
<p><strong>（2）音长</strong></p>
<p>四分之一音符、二分之一音符、全音符，通过延时简单处理，这样理解起来比较方便。</p>
<p><strong>（3）音量</strong></p>
<p>控制PWM的输出脉宽。这个值越大，发出的声音越大。当然要想达到理想的效果，还需要功放的帮助。</p>
<h3 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h3><p>单片机使用lpc2378，pwm输出后直接驱动喇叭发声。另一方面，实际的硬件接口输出电平为5V，喇叭使用12V才比较正常，所以声音输出比较小。</p>
<p>另一个重点就是音乐文件的生成。这个需要查看其它的资料。这里只是直接使用的网上的数据，该数据包含两部分：频率部分、时延部分，分别表示音调与音长。在程序运行时，先设置pwm为某一频率，之后延时对应的时间，然后重新开始下一个频率与延时。</p>
<p>如何查看简谱，可以参考网上的其它一些资料。下面的说明是网上的资料（<code>侵权删</code>）。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/203985"><code>简谱说明</code></a></p>
<p><img src="https://s3.ax1x.com/2021/02/21/yokhOP.png" alt="yokhOP.png"></p>
<ol>
<li><p>左上角的1=C是表示调式（可以不用关心），1是唱名，C是音名，1=C是正调（就是常规的对应关系: 1-C，2-D, 3-E, 4-F, 5-G, 6-A, 7-B）；</p>
</li>
<li><p>左上角的 4/4 是四四拍，是指 四分音符为一拍， 每小节有四拍；</p>
</li>
<li><p>下面谱子上的竖线就是每个小节分隔符，和4/4对应；</p>
</li>
<li><p>“跑得快”上面5后面的横线表示延时一拍；</p>
</li>
<li><p>“一直没有眼睛”一句，5后面的点表示顺延半拍，一条下划线表示二分之一时间，两条下划线表示四分之一时间；</p>
</li>
</ol>
<h3 id="3、其它"><a href="#3、其它" class="headerlink" title="3、其它"></a>3、其它</h3><p>还有另外一个想法，即奈奎斯特定理。对音频采样，只要符合该定理，那么就可以完整地恢复原始的音频。该方法似乎更简单，并不涉及到哪个频率是多少，音长是多少，却可以恢复原始的声音。比如电话，通过某一频率采样，电话的另一端就可以恢复说话人的声音。当然这里面还涉及到采样精度问题。</p>
<p>很自然的产生另外一个想法，是否可以通过频率合成的方式来实现声音的合成的？每一段音乐或者声音，包含不同的频率，每个频率又具有不同的幅度，应该需要一个巨大的运算量。</p>
<hr>
<h4 id="主要参考"><a href="#主要参考" class="headerlink" title="主要参考"></a>主要参考</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34358127">https://zhuanlan.zhihu.com/p/34358127</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1758279">https://cloud.tencent.com/developer/article/1758279</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/devymex/p/3389620.html">https://www.cnblogs.com/devymex/p/3389620.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/759222924lele/p/9771260.html">https://www.cnblogs.com/759222924lele/p/9771260.html</a></p>
<p><a target="_blank" rel="noopener" href="https://mbb.eet-china.com/forum/topic/71081_1_1.html">https://mbb.eet-china.com/forum/topic/71081_1_1.html</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/203985">https://bbs.huaweicloud.com/blogs/203985</a></p>
<p><a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/adb4c1f99f28447b35a3e39a209b86a5.html">https://www.huaweicloud.com/articles/adb4c1f99f28447b35a3e39a209b86a5.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.technics.com/cn/high-res-audio/what-is-high-resolution-audio.html">https://www.technics.com/cn/high-res-audio/what-is-high-resolution-audio.html</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1656128">https://cloud.tencent.com/developer/article/1656128</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/51379187">https://www.zhihu.com/question/51379187</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aya-lxl.github.io/2021/02/04/%E6%A0%85%E6%9E%81%E7%94%B5%E9%98%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aya_lxl@163.com">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="直到海角天涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/%E6%A0%85%E6%9E%81%E7%94%B5%E9%98%BB/" class="post-title-link" itemprop="url">栅极电阻</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-04 20:03:59 / 修改时间：20:05:07" itemprop="dateCreated datePublished" datetime="2021-02-04T20:03:59+08:00">2021-02-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%95%E7%89%87%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">单片机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1、现象"><a href="#1、现象" class="headerlink" title="1、现象"></a>1、现象</h4><p>这是最近在一个项目中遇到的问题。简单说来就是单片机输出PWM，经过驱动放大后输出的波形发生变形。</p>
<p>因为项目中的电路图不方便直接拿来，所以这里使用一个类似的电路图（<code>来源网络，侵权删除</code>）来表示，负载是一个电磁阀，电压为<code>24V</code>。单片机产生的信号会经过施密特触发器、三极管等处理，之后才是到达MOS管。关键点在于R3电阻。</p>
<p><img src="https://s3.ax1x.com/2021/02/04/y3YVAJ.png" alt="y3YVAJ.png"></p>
<p>正常的波形（也就是R3左侧）如下：</p>
<p><img src="https://s3.ax1x.com/2021/02/01/yZpkPs.png" alt="yZpkPs.png"></p>
<p>原始电路中，R3使用的是1M的电阻，最终的输出波形为：</p>
<p><img src="https://s3.ax1x.com/2021/02/01/yZpeMV.jpg" alt="yZpeMV.jpg"></p>
<p>很显然，这已经不能正常使用了。</p>
<p>将R3电阻换为2K后，输出波形就会正常，如下图。</p>
<p><img src="https://s3.ax1x.com/2021/02/01/yZpYM6.png" alt="yZpYM6.png"></p>
<p>需要说明的是，该图是在有电阻负载的情况下测量的。如果不更换2K电阻，那么即使存在负载，波形也是不正确的。对于更换电阻后，存在负载时波形会比无负载时的波形要好。</p>
<h4 id="2、理解"><a href="#2、理解" class="headerlink" title="2、理解"></a>2、理解</h4><p>栅极上串联的电阻既不能太大，也不能太小。太大会降低开关速度，导致功耗增加，性能降低；太小又会引发振荡，导致故障。目前而言，2K电阻是可以产生正常波形的，当然还需要看后续的测试情况进行改进。</p>
<h4 id="3、一些参考"><a href="#3、一些参考" class="headerlink" title="3、一些参考"></a>3、一些参考</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50357150">https://zhuanlan.zhihu.com/p/50357150</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107133948">https://zhuanlan.zhihu.com/p/107133948</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/145735392">https://zhuanlan.zhihu.com/p/145735392</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuoqingjoking97298/article/details/104133970">https://blog.csdn.net/zhuoqingjoking97298/article/details/104133970</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yunnGuitu/article/details/79624005">https://blog.csdn.net/yunnGuitu/article/details/79624005</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aya-lxl.github.io/2021/02/01/wwdg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aya_lxl@163.com">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="直到海角天涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/01/wwdg/" class="post-title-link" itemprop="url">wwdg</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-01 07:41:47 / 修改时间：07:47:20" itemprop="dateCreated datePublished" datetime="2021-02-01T07:41:47+08:00">2021-02-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%95%E7%89%87%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">单片机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>STM32F103窗口看门狗（Window watchdog）</p>
<h4 id="1、结构框图"><a href="#1、结构框图" class="headerlink" title="1、结构框图"></a>1、结构框图</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yV0yT0"><img src="https://s3.ax1x.com/2021/02/01/yV0yT0.png" alt="yV0yT0.png"></a></p>
<ul>
<li><p>从RCC产生的时钟经过4096分频后进入WDG预分频器</p>
</li>
<li><p>WWDG_CR寄存器之T[6:0]是看门狗计数器值，预分频器每产生一个时钟减一。当从0x40变为0x3F时产生看门狗复位（T6位跳变到0）。</p>
</li>
<li><p>WWDG_CFR寄存器之W[6:0]是窗口值，用来与递减计数器T进行比较，W[6:0]应该小于0x80。当计数器T的值小于W时才可以重新设置WWDG_CR的T值，也就是<code>喂狗</code>，如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yV0ckV"><img src="https://s3.ax1x.com/2021/02/01/yV0ckV.png" alt="yV0ckV.png"></a></p>
<p>也就是说<code>喂狗</code>需要在0X3F与W[6:0]这个<code>窗口</code>之间，过早过晚都会引起复位.</p>
<p>另外也可以看出，T[6:0]设置区间为0x40~0x7f.</p>
</li>
<li><p>WWDG_CFR之EWI位：提前唤醒中断 (Early wakeup interrupt) 此位若置’1’，则当计数器值达到40h，即产生中断。可以在中断中<code>喂狗</code>。</p>
</li>
<li><p>WWDG_CFR之WDGTB位：将预分频器的时钟再次分频，该位位0-3时分别分频1、2、4、8。所以可以得到如下的计算时间公式：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yV0gYT"><img src="https://s3.ax1x.com/2021/02/01/yV0gYT.png" alt="yV0gYT.png"></a></p>
</li>
<li><p>其它还包括使能位即状态位等。</p>
</li>
</ul>
<h4 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x_wwdg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wwdg_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = WWDG_IRQn;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);</span><br><span class="line"></span><br><span class="line">    WWDG_SetPrescaler(WWDG_Prescaler_8);</span><br><span class="line">    WWDG_SetWindowValue(<span class="number">0x7f</span>);</span><br><span class="line">    WWDG_SetCounter(<span class="number">0x7e</span>);</span><br><span class="line"></span><br><span class="line">    WWDG_ClearFlag();</span><br><span class="line">    WWDG_Enable(<span class="number">0x7e</span>);</span><br><span class="line">    WWDG_EnableIT();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WWDG_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(WWDG_GetFlagStatus())</span><br><span class="line">    &#123;</span><br><span class="line">        WWDG_ClearFlag();</span><br><span class="line">        WWDG_SetCounter(<span class="number">0x7e</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置过程还是比较简单的。</p>
<h4 id="3、问题"><a href="#3、问题" class="headerlink" title="3、问题"></a>3、问题</h4><p>但是引出另外一个问题，即<code>喂狗</code>在中断中处理是否合适？</p>
<p>比如在一篇文章中，作者认为（原文参考末尾链接）：</p>
<p><code>窗口看门狗WWDG----系统内部的故障探测器，时钟与系统相同。如果系统时钟不走了，这个狗也就失去了作用了，主要用于监视软件错误。</code></p>
<p><code>WWDG的中断不是用于日常喂狗的，如果用于日常喂狗动作，那WWDG的相对于IWDG，功能也就没什么特别了。WWDG的中断是给程序员最后一次喂狗的机会，一般进入这个中断时，表示你在其他地方安排的喂狗操不能凑效了，而发生这种现象时，肯定是系统有问题了，或者程序有Bug或者干扰，在这种情况下，这个中断时为了让你的程序在发生真正的看门狗复位前，有一个紧急处理的机会，如保存重要数据，或者系统刹车，说白了，就是让CPU写“遗嘱”；简单的在WWDG中断中喂狗，既没有发挥WWDG相对于IWDG的优势，又因为在中断中喂狗，而为以后的产品留下了隐患。</code></p>
<p>如果不在中断中处理，那么因为时间窗口的原因，处理起来可能会比较麻烦，就是需要每过一段时间进行一次<code>喂狗</code>，时间如何把控？</p>
<h4 id="4、参考"><a href="#4、参考" class="headerlink" title="4、参考"></a>4、参考</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012351051/article/details/50385074?utm_source=copy">https://blog.csdn.net/u012351051/article/details/50385074?utm_source=copy</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aya-lxl.github.io/2021/01/30/STM32%E4%B9%8BADC%E7%94%9F%E6%88%90%E6%B3%A2%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aya_lxl@163.com">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="直到海角天涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/30/STM32%E4%B9%8BADC%E7%94%9F%E6%88%90%E6%B3%A2%E5%BD%A2/" class="post-title-link" itemprop="url">STM32之ADC生成波形</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-30 21:07:24 / 修改时间：21:08:11" itemprop="dateCreated datePublished" datetime="2021-01-30T21:07:24+08:00">2021-01-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%95%E7%89%87%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">单片机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>平台：STM32F103VET6</p>
<h3 id="1、三角波"><a href="#1、三角波" class="headerlink" title="1、三角波"></a>1、三角波</h3><p>使用STM32F103 DAC输出三角波，定时器2触发。</p>
<p>PA5,也就是通道2,输出波形：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/ykU1eO"><img src="https://s3.ax1x.com/2021/01/30/ykU1eO.png" alt="ykU1eO.png"></a></p>
<p>调整幅值为2047后：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/ykUYYd"><img src="https://s3.ax1x.com/2021/01/30/ykUYYd.jpg" alt="ykUYYd.jpg"></a></p>
<p>在增加1V的DC偏移</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/ykUUSI"><img src="https://s3.ax1x.com/2021/01/30/ykUUSI.jpg" alt="ykUUSI.jpg"></a></p>
<p>通道1也可以，但是因为硬件原因，波形不正确。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/ykUwOf"><img src="https://s3.ax1x.com/2021/01/30/ykUwOf.png" alt="ykUwOf.png"></a></p>
<p>其输出波形：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/ykUBm8"><img src="https://s3.ax1x.com/2021/01/30/ykUBm8.png" alt="ykUBm8.png"></a></p>
<h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>(1) DAC配置</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dac1_init_triangle</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    DAC_InitTypeDef DAC_InitType;</span><br><span class="line"></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">    GPIO_SetBits(GPIOA, GPIO_Pin_5);</span><br><span class="line"></span><br><span class="line">    DAC_InitType.DAC_Trigger = DAC_Trigger_T2_TRGO;<span class="comment">//TIM2 TRGO事件</span></span><br><span class="line">    DAC_InitType.DAC_WaveGeneration =DAC_WaveGeneration_Triangle;</span><br><span class="line">    DAC_InitType.DAC_LFSRUnmask_TriangleAmplitude = DAC_TriangleAmplitude_2047;</span><br><span class="line">    DAC_InitType.DAC_OutputBuffer = DAC_OutputBuffer_Disable;</span><br><span class="line">    DAC_Init(DAC_Channel_2, &amp;DAC_InitType);</span><br><span class="line"></span><br><span class="line">    DAC_SetChannel1Data(DAC_Align_12b_R, <span class="number">0</span>);</span><br><span class="line">    DAC_SoftwareTriggerCmd(DAC_Channel_2,ENABLE);</span><br><span class="line">    DAC_Cmd(DAC_Channel_2, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置输出电压</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dac1_set_vol</span><span class="params">(<span class="keyword">float</span> vol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vol &gt; <span class="number">3.3</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    data = <span class="number">4096</span> * vol / <span class="number">3.3</span>;</span><br><span class="line">    DAC_SetChannel2Data(DAC_Align_12b_R, data); <span class="comment">//12位右对齐数据格式设置DAC值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(2)tim2配置</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tim2_init</span><span class="params">(u16 arr,u16 psc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;</span><br><span class="line">	</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">	TIM_DeInit(TIM2);</span><br><span class="line">	TIM_InternalClockConfig(TIM2);</span><br><span class="line">	TIM_TimeBaseStructure.TIM_Prescaler = psc<span class="number">-1</span>;	 <span class="comment">//72MHz分频系数</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	TIM_TimeBaseStructure.TIM_Period = arr<span class="number">-1</span>;</span><br><span class="line">	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line"></span><br><span class="line">	TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseStructure);</span><br><span class="line">	TIM_ClearFlag(TIM2, TIM_FLAG_Update);</span><br><span class="line">	TIM_SelectOutputTrigger(TIM2,TIM_TRGOSource_Update);<span class="comment">//更新事件被选为触发输入(TRGO)</span></span><br><span class="line">	TIM_ARRPreloadConfig(TIM2, ENABLE);</span><br><span class="line">	TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h3><p>内部的三角波计数器每次触发事件之后3个APB1时钟周期后累加1。计数器的值与DAC_DHRx寄存器的数值相加并丢弃溢出位后写入DAC_DORx寄存器。在传入DAC_DORx寄存器的数值小于MAMP[3:0]位定义的最大幅度时，三角波计数器逐步累加。一旦达到设置的最大幅度，则计数器开始递减，达到0后再开始累加，周而复始。  </p>
<p>上面这一段摘自<code>《STM32F10xxx参考手册  》</code>，在这里触发事件就是定时器2的TIM_TRGOSource_Update更新事件。所以，更改定时器的PSC与ARR即可改变三角波的周期。比如下图,PSC=6,ARR=1000。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/ykUykQ"><img src="https://s3.ax1x.com/2021/01/30/ykUykQ.jpg" alt="ykUykQ.jpg"></a></p>
<p>另一方面，三角波形的周期还与三角波的幅值有关，比如在上述定时器参数下，幅值变由DAC_TriangleAmplitude_2047变为DAC_TriangleAmplitude_1023，则波形变为：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/ykUcfs"><img src="https://s3.ax1x.com/2021/01/30/ykUcfs.jpg" alt="ykUcfs.jpg"></a></p>
<p>三角波的周期可以这样计算</p>
<ul>
<li><p>首先计算定时器触发频率：72M/(PSC+1)/ARR</p>
<p>这里PSC=5,ARR=1000,72M/(5+1)/1000=12K,那么周期就是1/12K.</p>
</li>
<li><p>三角波周期</p>
<p>DAC_TriangleAmplitude_2047时，则周期为2047*(1/12K)=170.6ms</p>
<p>DAC_TriangleAmplitude_1023时，则周期为1023*(1/12K)=85ms</p>
</li>
</ul>
<h3 id="4、噪声"><a href="#4、噪声" class="headerlink" title="4、噪声"></a>4、噪声</h3><p>  DAC沟通过那样可以产生噪声，只需要将配置中改为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DAC_InitType.DAC_WaveGeneration = DAC_WaveGeneration_Noise;</span><br><span class="line">DAC_InitType.DAC_LFSRUnmask_TriangleAmplitude=DAC_LFSRUnmask_Bits11_0;</span><br></pre></td></tr></table></figure>
<p>波形如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/ykUW60"><img src="https://s3.ax1x.com/2021/01/30/ykUW60.jpg" alt="ykUW60.jpg"></a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aya-lxl.github.io/2021/01/19/%E4%B8%B2%E5%8F%A3%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91%E4%B8%8E%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aya_lxl@163.com">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="直到海角天涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/19/%E4%B8%B2%E5%8F%A3%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91%E4%B8%8E%E7%9B%91%E6%8E%A7/" class="post-title-link" itemprop="url">串口数据转发与监控</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-19 20:45:57 / 修改时间：20:49:57" itemprop="dateCreated datePublished" datetime="2021-01-19T20:45:57+08:00">2021-01-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这个小软件是在某个项目中作为附属开发的工具，使用python开发。</p>
<h4 id="起因说明"><a href="#起因说明" class="headerlink" title="起因说明"></a>起因说明</h4><p>该项目中，单片机与Android屏通信，接口使用RS-232。二者之间的通信协议继承之前的结构，并且增加了许多新的功能。屏与单片机均可以主动发送数据，数据错误的时候还会重新发送。</p>
<p>通过实际的操作发现，有时候在屏上的操作会没有反应，原因是单片机未接收到数据（这种处理方式是协议设计的原因，即屏只是用来显示而不处理数据，操作每个按键都会下发数据，Android不关注具体每个键的作用，等到单片机接收并应答后才会响应），也就是存在数据丢失的情况。具体丢失哪些数据，在操作步骤的哪个节点上丢失无从得知。</p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p>原理很简单，就是在通信双方的链路中插入计算机，计算机将数据转发的同时，进行数据的显示与记录，这样对于双方的通信的数据就会比较清楚。原理框图如下。</p>
<p><img src="https://s3.ax1x.com/2021/01/19/s2wBHU.png" alt="s2wBHU.png"></p>
<p>正常工作时，数据通过上面的链路通信，调试时使用下面的链路，也就是数据会经过计算机的转发，与此同时实现数据的显示、存储与分析。</p>
<h4 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h4><p>主要包括2个库：tkinter用来做界面，serial用来操作串口。效果如下图。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/s2wrEF"><img src="https://s3.ax1x.com/2021/01/19/s2wrEF.png" alt="s2wrEF.png"></a></p>
<p>可以对串口进行选择，对串口参数进行配置。</p>
<p>最后两个按键可以实现清屏处理与数据保存，数据保存按照时间命名为txt文件，方便查看与处理。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/s2waj0"><img src="https://s3.ax1x.com/2021/01/19/s2waj0.png" alt="s2waj0.png"></a></p>
<p>文件中的保存方式就是软件中数据的显示方式，如下。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/s2wwuV"><img src="https://s3.ax1x.com/2021/01/19/s2wwuV.png" alt="s2wwuV.png"></a></p>
<h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>这个小软件发挥了很大的作用，除了上面提到的数据丢失问题，还发现了其它一些不容易出现的问题，这样就可以更有针对性的优化软件。</p>
<p>一个需要注意的问题是数据显示。因为有两个串口可能会同时接收到数据，那么显示数据时可能就会有冲突。所以需要一个<code>锁</code>来保证数据写入的正常，待数据写入完成后，释放锁。</p>
<p>再说一句，这个项目中单片机软件的实现架构不太好，uart数据接收方式也有问题，另外一些操作相当费时。比如键盘上的LCD屏，调试的时候发现，竟然需要100多毫秒。而上面所说的数据重发数据间隔并没有那么长，基本上也就50ms左右。某些情况下，两帧数据会连续发送，其发送间隔很小，如果在处理接收的数据过程中存在比较费时的操作，那么下次的是数据可能就会无法正常接收，也就是会造成数据丢失。究其根本，还是单片机接收Android下发的数据存在比较大的问题，这个项目会在另一篇中详细说明。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aya-lxl.github.io/2021/01/18/%E6%95%B0%E6%8D%AE%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E5%B0%8F%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aya_lxl@163.com">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="直到海角天涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/18/%E6%95%B0%E6%8D%AE%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E5%B0%8F%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">数据图形显示小工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-18 19:41:53 / 修改时间：20:09:41" itemprop="dateCreated datePublished" datetime="2021-01-18T19:41:53+08:00">2021-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-来历"><a href="#1-来历" class="headerlink" title="1 来历"></a>1 来历</h2><p>采用python编写的一个小工具，用来对接收到的数据进行图形化显示，目的是方便观察数据的波动。如果在考虑其它一些功能，比如计算均值、方差等，则可以更全面的对数据进行描述与解释。</p>
<p>因为工作中某个项目的原因，需要通过比例调节阀来控制液体流速。而控制比例调节阀的基础就是液体的流速，而测量流速的准确性关系到实际调节的准确性。所以该工具的目的就是在软件调试阶段，对流速测量与比例调节阀调节准确性进行评估，以便改进软件。</p>
<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h2><p>软件主要用到2个库：matplotlib、serial。</p>
<p>首先打开串口，当然需要设置串口的参数，诸如波特率、校验等。当接收到数据时，进行绘图。这里有2种方法，（1）每次只画一个点，之前的点不清除；（2）每次清除之前的点，重新绘制所有的点，包括新接收到的点。显而易见，第二种方法比较耗费资源。两种方法的图形如下所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/scnfCd"><img src="https://s3.ax1x.com/2021/01/18/scnfCd.png" alt="scnfCd.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/scngED"><img src="https://s3.ax1x.com/2021/01/18/scngED.png" alt="scngED.png"></a></p>
<p>其实，两种方法都可以看出动态效果，但是第二种方法画出的点是连在一起的显。</p>
<h2 id="3-工况"><a href="#3-工况" class="headerlink" title="3 工况"></a>3 工况</h2><p>再来看一下实际中需要测量的液体流速。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/scnR4H"><img src="https://s3.ax1x.com/2021/01/18/scnR4H.png" alt="scnR4H.png"></a></p>
<p>可以看到尖峰存在，而且是两种峰值，似乎也有一定的周期性，猜想可能是某种系统性的原因引起的，可能是软件引起的，也可能是硬件引起的，或者干脆就是泵的稳定性有点差。</p>
<p>但是数据仍稳定在一个较小的区间之内，比如上述图形数据的均值为89.41，标准差为0.13.</p>
<p>如果存在外部的、独立的流速测量仪器，那么可以将其作为基准使用。但是，因为条件的限制，只能使用目前这种方法来调试。另外一个比较重要的原因是，该设备对流速没有很高的精度要求，每分钟40L或者45L影响不大，但是不能是每分钟80L。</p>
<h2 id="4-结尾"><a href="#4-结尾" class="headerlink" title="4 结尾"></a>4 结尾</h2><p>该小程序只是个人作为调试使用的，为了方便工作。如果有需要，还可以增加串口参数设置、接收数据统计显示、数据保存等功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aya-lxl.github.io/2021/01/17/hexo%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aya_lxl@163.com">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="直到海角天涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/17/hexo%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">hexo安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-17 13:18:54 / 修改时间：19:28:52" itemprop="dateCreated datePublished" datetime="2021-01-17T13:18:54+08:00">2021-01-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%AB%99/" itemprop="url" rel="index"><span itemprop="name">网站</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="0-关于本文"><a href="#0-关于本文" class="headerlink" title="0 关于本文"></a>0 关于本文</h2><p>本文仅仅是作为个人搭建过程的一个简单记录。</p>
<p>本文参考了网上诸多资料，未能将全部参考信息包含进去，非常感谢各位。若有侵权，联系<a href="aya_lxl@163.com">邮箱</a>删除。</p>
<h2 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1 安装git"></a>1 安装git</h2><ol>
<li>配置user信息</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的GitHub用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>生成ssh密钥文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>
<p>直接三个回车即可，默认不需要设置密码。</p>
<p>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制。</p>
<p>打开key设置页面，新建new SSH Key。</p>
<p><img src="https://pic1.zhimg.com/v2-72a3f22c080e99343c3cc4aabce10e3c_r.jpg" alt="github setting keys"></p>
<p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。<br>在Git Bash中检测GitHub公钥设置是否成功，输入 ssh git@giTitle为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。<br>在Git Bash中检测GitHub公钥设置是否成功，输入 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure>
<p> <img src="https://pic3.zhimg.com/80/v2-da481ffa686410becd4186c656b4ebd6_1440w.jpg" alt="github key set resp"></p>
<p>如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。</p>
<p>第一次安装可能会不正确，此时，在上述命令下，输入yes,回车，会在.ssh的文件夹下生成<code>known_hosts</code>文件.</p>
</li>
</ol>
<h2 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2 安装Node.js"></a>2 安装Node.js</h2><p>Hexo基于Node.js，Node.js下载地址：<a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">Download | Node.js</a> 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v :</p>
<p><img src="https://pic1.zhimg.com/80/v2-76ea38e9545e606f975781e47933b010_1440w.jpg" alt="node -v"></p>
<p>检测npm是否安装成功，在命令行中输入npm -v :</p>
<p><img src="https://pic2.zhimg.com/80/v2-bede250b8456df92475b455fda8c1dd9_1440w.jpg" alt="npm -v"></p>
<h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3 安装Hexo"></a>3 安装Hexo</h2><p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。</p>
<p><strong><em>以下命令可能需要在管理员模式(win10)下使用</em></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<p>为了检测我们的网站雏形，分别按顺序输入以下三条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new test_my_site</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>这些命令在后面作介绍，完成后，打开浏览器输入地址：localhost:4000</p>
<p>如果提示找不到server命令则需要运行命令<code>$ npm install hexo-server --save</code></p>
<h2 id="4-创建站点"><a href="#4-创建站点" class="headerlink" title="4 创建站点"></a>4 创建站点</h2><p>可参考官方文档<a target="_blank" rel="noopener" href="https://docs.github.com/cn/github/working-with-github-pages/creating-a-github-pages-site#creating-a-repository-for-your-site">创建 GitHub Pages 站点</a></p>
<h2 id="5-推送网站"><a href="#5-推送网站" class="headerlink" title="5 推送网站"></a>5 推送网站</h2><p>在blog根目录里的_config.yml文件称为<strong>站点</strong>配置文件，如下图</p>
<p><img src="https://pic2.zhimg.com/80/v2-cb1fd5e5a2e73f513234e434724c7c55_720w.jpg" alt="站点配置文件"></p>
<p>进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为<strong>主题</strong>配置文件，如下图</p>
<p><img src="https://pic4.zhimg.com/80/v2-4252029e5634bf91c7d58916ae2b8ac3_720w.jpg" alt="主题配置文件"></p>
<p>下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</p>
<p>deploy:<br>type: git<br>repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git<br>branch: master</p>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:aya-lxl/aya-lxl.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>


<p>保存站点配置文件。</p>
<p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>


<p>这时，我们分别输入三条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 <a href="http://aya-lxl.github.io/">http://aya-lxl.github.io</a>.</p>
<p>你就会发现你的博客已经上线了，可以在网络上被访问了。</p>
<h2 id="7-其它"><a href="#7-其它" class="headerlink" title="7 其它"></a>7 其它</h2><p>删除文章的过程一样也很简单，先删除本地文件，然后通过生成和部署命令进而将远程仓库中的文件也一并删除。具体来说，以最开始默认形成的<code>helloworld.md</code>这篇文章为例。</p>
<p>首先进入到source / _post 文件夹中，找到<code>helloworld.md</code>文件，在本地直接执行删除。然后依次执行<code>hexo g</code>，<code>hexo d</code>，再去主页查看你就会发现你的博客上面已经空空如也了，这就是如何删除文章的方法。</p>
<h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/84a8384be1ae">https://www.jianshu.com/p/84a8384be1ae</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Time888/article/details/70249241">https://blog.csdn.net/Time888/article/details/70249241</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aya_lxl@163.com</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aya_lxl@163.com</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
